# chapter03_dictionary and set (2)

Created: Mar 3, 2021 8:57 PM

### 3.7 immutable mapping

python 3.3이후 types 모듈은 MappinProxyType이라는 wrapper class를 제공해서, 원래 매핑의 동적인 뷰를 제공하지만 읽기 전용의 mappingproxy 객체를 반환한다. 

```bash
from types import MappingProxyType
d = {1:'A'}
d_proxy = MappingProxyType(d)
print(d)
d_proxy[1]
# d_proxy[2] = 'x' # 불가능
d[2] = 'B'
print(d_proxy)
print(d_proxy[2])
'''
d_proxy는 변경할수 없고, 다이나믹한 d_proxy는 d에 대한 변경을 바로 반영한다.
'''
```

### 3.8 집합 이론

집합은 고유한 객체의 모음으로서, 기본적으로 중복 항목을 제거한다.

집합 요소는 반드시 해시할 수 있어야한다. set은 해시 가능하지 않지만 frozenset은 해시가능하므로, frozenset이  set에 들어갈 수 있다.

집합 연산을 현명하게 이용하면 파이썬 프로그램의 소스코드 크기와 실행시간을 줄일수 있을 뿐 아니라, 루프 조건절이 없어지므로 코드와 가독성이 높아진다. 

### 3.8.1 집합 리터럴

{1,2,3}과 같은 리터럴 집합 구문은 set([1,2,3]) 처럼 생성자를 호출하는 것보다 빠르고 가독성이 더 좋다. 생성자를 명시적으로 호출하는 경우에는 파이썬이 생성자를 가져오기 위해 집합명을 검색하고, 리스트를 생성하고, 이 리스트를 생성자에 전달해야 하므로 더 느리다. 반면 리터럴 집합 구문을 처리하는 경우, BUILDSET이라는 특수한 바이트 코드를 실행한다. 

```python
l = ['spam','spam','eggs','spam']
print(set(l))
print(list(set(l)))

# dis.dis() 디어셈블러 함수
from dis import dis
print(dis('{1}'))
print(dis('set([1])'))
'''
	1           0 LOAD_CONST               0 (1)
              2 BUILD_SET                1
              4 RETURN_VALUE

  1           0 LOAD_NAME                0 (set)
              2 LOAD_CONST               0 (1)
              4 BUILD_LIST               1
              6 CALL_FUNCTION            1
              8 RETURN_VALUE
'''
print(frozenset(range(10)))
```

frozenset에 대한 별도의 리터럴 구문은 없으므로 언제나 생성자 호출해서 생성. 

### 3.8.2 set comprehension

```python
from unicodedata import name
code = {chr(i) for i in range(32,256) if 'SIGN' in name(chr(i),'')}
print(code)
'''
{'#', '%', '=', 'µ', '¶', '¤', '±', '©', '×', '¥', '§', '£', '$', '¬', '°', '+', '<', '÷', '¢', '®', '>'}
'''
```

### 3.8.3 집합 연산

중위 연산자는 양쪽 피연산자가 모두 집합이어야 하지만, 그 외 메서드는 하나 이상의 반복 가능한 인수를 받을 수 있다. 에를 들어 a.union(b,c,d) 형태에서 a는 반드시 집합, b,c,d는 어떠한 자료형도 가능하다. 

### 3.9 dict와 set의 내부 구조

파이썬이 해시 테이블을 이용해서 딕셔너리와 집합을 구현하는 방식을 알면, 그들의 장점과 단점을 이해하는데 도움이 된다. 

이 절에서는 다음 질문에 대해 답한다.

Q. 파이썬의 dict과 set은 얼마나 효율적인가?

Q. 왜 순서가 없을까?

Q. dict의 키와 set 항목에 파이썬의 모든 객체를 사용할 수 없는 이유는 무엇인가?

Q. dict의 키와 set 항목의 순서가 왜 삽입 순서에 따라 달라지며, 객체 수명 주기 동안 이 순서가 바뀔 수 있는 이유는 무엇인가?

Q. 딕셔너리와 집합을 반복하는 동안 항목을 추가하면 왜 안될까?

### 3.9.1 성능 실험

경험을 통해 모든 파이썬 개발자는 dict과 set이 빠르다는 것을 알고 있다. i7 코어 기준, 1000개의 실수 키를 1천개의 항목을 가진 딕셔너리에서 검색하는데 0.000202초 걸렸다. 1천만개의 항목을 가진 딕셔너리에서 검색하는 데 0.000337초, 하나당 0.337마이크로초가 걸렸다.

list → O(n), set,dictionary → O(1)이라 할수 있다.

프로그램에서 외부장치로의 입출력을 수행한다면 dict나 set의 크기에 상관없이 키 검색 시간은 무시할 정도로 작다. 

해시테이블의 내부를 이해하면 키들이 무작위 순서로 불안정하게 정렬되는 이유를 알 수 있다.

### 3.9.2 딕셔너리 안의 해시 테이블

(CPython은 몇 가지 최적화 기법을 사용하고 있지만, 자세한 설명 생략하고 전반적인 구조 위주로.)

해시 테이블은 희소배열 sparse array이다. 해시 테이블 안에 있는 항목을 bucket 이라고 한다. dict 해시 테이블에는 각 항목 별로 버킷이 있고, 버킷에는 키에 대한 참조와 항목의 값에 대한 참조가 들어간다. 모든 버킷의 크기가 동일하므로 오프셋을 게산해서 각 버킷에 바로 접근할 수 있다.

파이썬은 버킷의 1/3 이상을 비워두려고 노력한다. 해시테이블 항목이 많아지면 더 넓은 공간에 복사해서 버킷 공간을 확보한다. 해시테이블안에 항목을 넣을 떄, 먼저 항목 키의 해시값을 계산한다. 해시는 hash() 내장함수를 이용해서 계산한다. 

**해시와 동치성**

hash() 내장함수는 내장 자료형은 직접 처리하고 사용자 정의 자료형의 경우 __hash__()  메서드를 호출한다. 두 객체가 동일하면 이 값들의 해시값도 동일해야한다. 그렇지 않으면 해시 테이블 알고리즘이 제대로 작동하지 않는다. 1 == 1.0 이려면 hash(1) == hash(1.0)이어야 한다. 

해시 테이블 인덱스 처럼 효율성을 높이려면 해시값이 가능한 한 인덱스 공간에 골고루 퍼져야 한다. 즉, 이상적으로는 비슷하지만 동일하지 않은 객체들의 해시값은 상당히 달라야한다. 

**해시 테이블 알고리즘**

my_dict[search_key]에서 값을 가져오기 위해 파이썬은 __hash__(search_key)를 호출해서 search_key의 해시값을 가져오고, 해시값의 최하위 비트를 해시 테이블안의 버킷에 대한 오프셋으로 사용한다.(사용하는 비트 수는 현재 테이블의 크기에 따라 달라진다.) 찾아낸 버킷이 비어있으면 KeyError를 발생시키고, 그렇지 않으면 버킷에 들어 있는 항목인 (found_key : found_value)쌍을 검사해서 search_key == found_key인지 검사한다. 일치하면 항목을 찾은 것이므로 found_key 반환한다.

search_key와 found_key가 다른 경우 hash collsion 발생. 해시 충돌은 해시 함수가 임의의 객체를 적은 수의 비트로 매핑하기 때문에 발생한다. 해시 충돌을 해결하기 위해 알고리즘은 해시의 다른 비트를 가져와서 특정한 방식으로 조작한 후 그 결과를 이용해서 다른  버킷을 조회한다. 

항목을 추가할 때 해시테이블에 항목이 너무 많다고 파이썬이 판단하면 더 큰 공간을 가진 새로운 위치에 해시 테이블을 다시 만든다. 해시 테이블이 커지면 더 많은 해시 비트를 버킷 오프셋으로 사용하며, 더많은 비트를 사용할 수록 충돌률이 낮아진다. 

### 3.9.3 dict 작동 방식에 의한 영향

dict에서 사용하는 해시 테이블의 한계와 장점. 

**키 객체는 반드시 해시 가능해야 한다**

다음 조건 만족하는 모든 객체는 해시 가능 하다. 

1. 객체의 수명 주기동안 언제나 동일한 값을 반환하는 __hash__() 메서드를 제공해서 hash()함수를 지원한다.
2. __eq__() 메서드를 통해 동치성을 판단할 수 있어야한다.
3. a==b 참이면, hash(a) == hash(b) 도 반드시 참이어야 한다.

사용자 정의 자료형은 id()를 해시값으로 사용한다.

**dict의 메모리 오버헤드가 크다**

dict가 내부적으로 해시 테이블을 사용하고 있고 해시가 제대로 작동하려면 빈 공간이 충분해야 하므로, dict 메모리 공간 효율성은 높지 않다. 

예를 들어 많은 양의 레코드를 처리하는 경우, JSON 형태로 각 레코드에 하나의 dict을 할당해서 딕셔너리의 리스트를 사용하는 것 보다 튜플이나 명명된 튜플의 리스트에 저장하는 것이 좋다. dict를 튜플로 교체하면, 레코드마다 하나의 해시 테이블을 가져야 하는 부담과 필드명을 다시 저장해야 하는 부담을 제거함으로써 메모리 사용량을 줄일 수 있다. 

키 검색이 아주 빠르다

dict는 속도를 위해 공간을 포기한 예이다. 딕셔너리는 메모리 오버헤드가 상당히 크지만, 메모리에 로딩되는 한 딕셔너리 크기와 무관하게 빠른 접근 속도를 제공한다. 요소개수를 10^3 → 10^7 하였을때, 걸리는 속도는 2.8배 증간한다.  1천만개의 항목의 dict에 2백만개 검색하는데 1초도 걸리지 않는다. 

### 키 순서는 삽입 순서에 따라 달라진다.

해시 충돌이 발생하면 두번째 키는 발생하지 않았을 때의 정상적인 위치와 다른 곳에 놓이게 된다. dict([(key1,value1), (key2,value2)])로 생성한 딕셔너리와 dict([(key2, value2), (key1,value1)])으로 생성한 딕셔너리는 동일하지만 key1, key2의 해시가 충돌하면 키의 순서가 달라진다. 

동일한 데잍처를 가진 세개의 딕셔너리를 다른 순서로 로딩한 결과이다. 생성된 딕셔너리는 순서는 달라도 모두 동일하다고 판단된다. 

```python
DIAL_CODES = [
    (86, 'china'),
    (91, 'India'),
    (1, 'United States'),
    (62, 'Indonesia'),
    (82,'korea')
]

d1 = dict(DIAL_CODES)
print('d1:',d1.keys())
d2 = dict(sorted(DIAL_CODES))
print('d2:',d2.keys())
d3 = dict(sorted(DIAL_CODES,key=lambda x:x[1]))
print('d3:',d3.keys())
assert d1==d2 and d2==d3
'''
d1: dict_keys([86, 91, 1, 62, 82])
d2: dict_keys([1, 62, 82, 86, 91])
d3: dict_keys([91, 62, 1, 86, 82])
'''
```

### 딕셔너리에 항목을 추가하면 기존 키의 순서가 변경될 수 있다.

dict에 항목을 추가할 때 마다 파이썬 인터프리터는 그 딕셔너리의 해시 테이블 크기를 늘릴지 판단한다. 그리고 더 큰 해시테이블을 새로 만들어서 기존 항목을 모두 새 테이블에 추가한다. 이 과정 동안 기존과 다르게 해시 충돌이 발생해서 새로운 해시 테이블에서의 키 순서가 달라질 수 있다. ( 구현 알고리즘에 따라 달라진다.)

딕셔너리 키를 반복하는 도중 항목을 변경하는 경우, 원하는 대로 항목을 검색하지 못하는 경우가 발생할 수 있다. 심지어 추가하기 전에 이미 있던 항목도 제대로 검색하지 못할 수 있다.

딕셔너리를 검색하면서 항목을 추가해야 하는 경우 다음 두단계로 수행한다.

1. 처음부터 끝까지 딕셔너리를 검색하면서 필요한 항목은 별도의 딕셔너리에 추간한다.
2. 별도의 딕셔너리로 원래 딕셔너리를 갱신한다. 

### 3.9.4 집합의 작동 방식 - 현실적으로 미치는 영향

set과 frozenset도 해시 테이블을 이용해서 구현하지만, 각 버킷이 항목에 대한 참조만을 담고 있다는 점이 다르다. 항목 자체가 dict의 key처럼 사용되지만, 이 키를 통해 접근할 값은 없다. 사실 set이 파이썬 언어에 추가되기 전까지 가짜 값을 가진 딕셔너리를 사용해서 키가 들어있는지 빠르게 검사했다.

- set 요소는 모두 해시 간으한 객체여야 한다.
- set의 메모리 오버헤드는 상당히 크다.
- 집합에 속해 있는지 매우 효율적으로 검사할 수 있다.
- 요소의 순서는 요소를 추가한 순서에 따라 달라진다.
- 요소를 집합에 추가하면 다른 요소의 순서가 바뀔 수 있다.